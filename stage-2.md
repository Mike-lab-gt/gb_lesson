# Заголовок 1
## Заголовок 2
### Заголовок 3

| Column 1 | Column 2 | Column 3 |
|----------|----------|----------|
| Row 1 | Cell 2 | Cell 3 |
| Row 2 | Cell 5 | Cell 6 |
| Row 3 | Cell 8 | Cell 9 |

<table>
<tr>
<th>Заголовок 1</th>
<th>Заголовок 2</th>
</tr>
<tr>
<td>Ячейка 1.1</td>
<td>Ячейка 2.1</td>
</tr>
<tr>
<td>Ячейка 1.2</td>
<td>Ячейка 2.2</td>
</tr>
</table>


![Krasivo](https://moon.kz/upload/iblock/61a/5vpg05ysvar35qf8ssfw62l2ltujc100.jpg)
![mygif](https://media1.tenor.com/m/5BYK-WS0__gAAAAd/cool-fun.gif)
[![music](https://almaty.tv/news_photo/1638002982_news_b.webp)](https://youtu.be/K5DALXwOe0s?si=Np6KiCGQESoPaTxk)

<img src=https://moon.kz/upload/iblock/61a/5vpg05ysvar35qf8ssfw62l2ltujc100.jpg width=300>



- строка
- строка2 
- строка3


## Нумерованный список
1. Пункт первый
2. Пункт второй
3. Пункт третий
## Маркированный список
- Пункт первый
- Пункт второй
- Пункт третий
# Вложенные списки
Также можно делать вложенные списки, добавляя 4 пробела перед пунктом:

1. Пункт первый
- Подпункт первый
- Подпункт второй
2. Пункт второй\вв

<table>
<tr>
<th>Заголовок 1</th>
<th>Заголовок 2</th>
</tr>
<tr>
<td>Ячейка 1.1</td>
<td>Ячейка 2.1</td>
</tr>
<tr>
<td>Ячейка 1.2</td>
<td>Ячейка 2.2</td>
</tr>
</table>

| Column 1 | Column 2 | Column 3 |
|----------|----------|----------|
| Строка 1 | Ячейка 2 | Ячейка 3 |
| Строка 2 | Ячейка 5 | Ячейка 6 |
| Строка 3 | Ячейка 8 | Ячейка 9 |
<img src=https://moon.kz/upload/iblock/61a/5vpg05ysvar35qf8ssfw62l2ltujc100.jpg width=300>

# Создание репозитория
## **git init**
После исполнения команды появится сообщение об инициализации репозитория. Оно означает, что Git начал отслеживать файлы проекта и будет записывать изменения в скрытую папку .git. Если вам понадобится инициализировать новый репозиторий — повторите процедуру. На одном компьютере Git может одновременно управлять неограниченным количеством репозиториев.

В командной строке удобно не только работать с Git, но и перемещаться по проекту. Вот список базовых команд, которые могут пригодиться:
- pwd — просмотр вашего текущего местоположения
- ls — список папок и файлов в текущей директории, где была выполнена команда
- ls -a — список открытых и скрытых папок и файлов в текущей директории, где была выполнена команда
- cd ~ — переход в домашнюю директорию текущего пользователя
- cd .. — переход на один уровень вверх в иерархии файловой системы
- cd folder_name — переход в выбранную папку;
- mkdir folder_name — создать папку с указанным именем

## **git add: добавление файлов в индекс**
Если вы создадите в проекте файл, то Git его посчитает неотслеживаемым (untracked). Такие файлы нельзя перенести в репозиторий без подготовки к сохранению. За подготовку отвечает индекс — промежуточная зона перед репозиторием. Перенести файлы в индекс можно с помощью команды *git add*.

В индекс можно добавить один файл, несколько или все сразу. После попадания в индекс файлы становятся подготовленными к коммиту

- git add file_name

- git add file_name_1 file_name_2 file_name_3

# **git status: проверка статуса репозитория**
Команда *git status* даёт представление о текущем состоянии репозитория. Она показывает, какие неотслеживаемые файлы попали в проект, какие файлы находятся в индексе и какие сохранённые файлы вы изменили в репозитории.

# **git commit: добавление файлов в репозиторий**
Когда все файлы подготовлены к сохранению, их можно перенести из индекса в репозиторий. Для этого нужна команда git commit с опцией -m и сообщением коммита. Сообщение пишется в кавычках и обычно латиницей
- git commit -m "Commit message"

# **git log: просмотр журнала коммитов**
Команда *git log* показывает историю коммитов в обратном хронологическом порядке. Вы можете посмотреть хеш, сообщение, дату и ник автора коммита

# **git show: просмотр коммита**
Команда *git show* выводит информацию об одном коммите. Сообщение делится на два блока: часть с метаданными и список изменений, внесённых в коммит

# **git diff: просмотр изменений до коммита**
Команда *git diff* показывает разницу между последним коммитом и текущим состоянием репозитория. То есть последний коммит сравнивается со всеми неотслеживаемыми файлами, которые ещё не переведены в индекс

# **git restore: отмена изменений**
Команда *git restore* возвращает файл к состоянию последнего коммита. Она отменяет все изменения, если файл не перенесён в индекс. Если файл попал в индекс, то вместе с названием команды нужно использовать опцию *--staged*

# **git reset: откат коммита**
Команда git reset позволяет отменить любое количество сделанных коммитов и вернуть проект к какому-то состоянию в прошлом. Команду нужно выполнять с осторожностью, поскольку она может навсегда переписать историю проекта.

На выбор можно использовать три режима: --soft, --mixed и --hard.

В режиме --soft проект откатывается к указанному коммиту и переводит все последующие коммиты в индекс. Вы можете сразу сделать новый коммит и перезаписать историю проекта, оставив исходные файлы без изменений.

В режиме --mixed откаченные файлы попадают в неотслеживаемую зону. Вы можете эти файлы изменить, удалить или вернуть обратно в индекс.

В режиме --hard проект откатывается к указанному коммиту и удаляет все последующие коммиты без возможности их восстановления.

# Ветвление
# **git branch <branch_name>: создание новой ветки**
После первого коммита Git автоматически создаёт первую ветку. Обычно в ней хранят стабильную версию проекта для пользователей продукта. Под остальные задачи разработчики создают отдельные ветки с помощью команды git branch
- git branch branch_name

Ветку с неудачным названием можно переименовать:
- git branch -m old_branch_name new_branch_name

# **git branch: просмотр веток**
Команда git branch позволяет получить список всех доступных веток в проекте. Также она проставляет символ звёздочки слева от текущей активной ветки

# **git checkout: переключение между ветками**
Команда git checkout позволяет переключиться с одной ветки на другую
- git checkout branch_name

# **git merge: слияние репозиториев**
Команда git merge позволяет добавить изменения из одной ветки в другую. Такой процесс называется слиянием, и он завершается появлением общего коммита для объединённых веток. По этому коммиту можно отследить историю каждой ветки.

## **git branch -d <branch_name>: удаление ветки**
осле слияния второстепенная ветка больше не нужна и мы её можем удалить.

 # Удалённый репозиторий
 # **git remote add origin url: привязка локального и удалённого репозитория**
 С помощью командной строки переместитесь в папку с проектом на своём компьютере. Теперь вы можете выполнить команду git remote add, которая установит связь между вашим локальным и удалённым репозиторием на GitHub.

 ## **git remote: просмотр удалённых репозиториев**
 Если вы часто взаимодействуете с GitHub, то с вашим локальным может быть связано множество удалённых репозиториев. Если ввести команду git remote, то можно посмотреть название этих репозиториев и отсортировать все ненужные.

 # **git remote — v: просмотр удалённых URL-адресов**
 Команда git remote показывает только названия удалённых репозиториев, которые связаны с вашим локальным. К команде можно добавить опцию -v и посмотреть удалённые URL-адреса. По URL-адресам будет видно, какие изменения вы делали.

# **git push: отправка изменений в удалённый репозиторий**
Команда git push загружает изменения из локального репозитория в удалённый.

Во время первой загрузки нужно использовать команду с опцией -u. Это свяжет локальную и удалённую ветки и синхронизирует их для последующих операций. Для второй и всех последующих загрузок опция -u для связанных веток не понадобится.

# **git pull: получение изменений из удалённого репозитория**
Команда git pull скачивает изменения из удалённого репозитория в локальный.
